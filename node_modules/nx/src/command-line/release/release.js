"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.release = exports.releaseCLIHandler = void 0;
const enquirer_1 = require("enquirer");
const nx_json_1 = require("../../config/nx-json");
const devkit_exports_1 = require("../../devkit-exports");
const project_graph_1 = require("../../project-graph/project-graph");
const params_1 = require("../../utils/params");
const changelog_1 = require("./changelog");
const config_1 = require("./config/config");
const filter_release_groups_1 = require("./config/filter-release-groups");
const publish_1 = require("./publish");
const git_1 = require("./utils/git");
const resolve_nx_json_error_message_1 = require("./utils/resolve-nx-json-error-message");
const shared_1 = require("./utils/shared");
const version_1 = require("./version");
const releaseCLIHandler = (args) => (0, params_1.handleErrors)(args.verbose, () => release(args));
exports.releaseCLIHandler = releaseCLIHandler;
async function release(args) {
    const projectGraph = await (0, project_graph_1.createProjectGraphAsync)({ exitOnError: true });
    const nxJson = (0, nx_json_1.readNxJson)();
    if (args.verbose) {
        process.env.NX_VERBOSE_LOGGING = 'true';
    }
    const hasVersionGitConfig = Object.keys(nxJson.release?.version?.git ?? {}).length > 0;
    const hasChangelogGitConfig = Object.keys(nxJson.release?.changelog?.git ?? {}).length > 0;
    if (hasVersionGitConfig || hasChangelogGitConfig) {
        const jsonConfigErrorPath = hasVersionGitConfig
            ? ['release', 'version', 'git']
            : ['release', 'changelog', 'git'];
        const nxJsonMessage = await (0, resolve_nx_json_error_message_1.resolveNxJsonConfigErrorMessage)(jsonConfigErrorPath);
        devkit_exports_1.output.error({
            title: `The "release" top level command cannot be used with granular git configuration. Instead, configure git options in the "release.git" property in nx.json, or use the version, changelog, and publish subcommands or programmatic API directly.`,
            bodyLines: [nxJsonMessage],
        });
        process.exit(1);
    }
    // Apply default configuration to any optional user configuration
    const { error: configError, nxReleaseConfig } = await (0, config_1.createNxReleaseConfig)(projectGraph, nxJson.release);
    if (configError) {
        return await (0, config_1.handleNxReleaseConfigError)(configError);
    }
    // These properties must never be undefined as this command should
    // always explicitly override the git operations of the subcommands.
    const shouldCommit = nxJson.release?.git?.commit ?? true;
    const shouldStage = (shouldCommit || nxJson.release?.git?.stageChanges) ?? false;
    const shouldTag = nxJson.release?.git?.tag ?? true;
    const versionResult = await (0, version_1.releaseVersion)({
        ...args,
        stageChanges: shouldStage,
        gitCommit: false,
        gitTag: false,
    });
    await (0, changelog_1.releaseChangelog)({
        ...args,
        versionData: versionResult.projectsVersionData,
        version: versionResult.workspaceVersion,
        stageChanges: shouldStage,
        gitCommit: false,
        gitTag: false,
    });
    const { error: filterError, releaseGroups, releaseGroupToFilteredProjects, } = (0, filter_release_groups_1.filterReleaseGroups)(projectGraph, nxReleaseConfig, args.projects, args.groups);
    if (filterError) {
        devkit_exports_1.output.error(filterError);
        process.exit(1);
    }
    if (shouldCommit) {
        devkit_exports_1.output.logSingleLine(`Committing changes with git`);
        const commitMessage = nxReleaseConfig.git.commitMessage;
        const commitMessageValues = (0, shared_1.createCommitMessageValues)(releaseGroups, releaseGroupToFilteredProjects, versionResult.projectsVersionData, commitMessage);
        await (0, git_1.gitCommit)({
            messages: commitMessageValues,
            additionalArgs: nxReleaseConfig.git.commitArgs,
            dryRun: args.dryRun,
            verbose: args.verbose,
        });
    }
    if (shouldTag) {
        devkit_exports_1.output.logSingleLine(`Tagging commit with git`);
        // Resolve any git tags as early as possible so that we can hard error in case of any duplicates before reaching the actual git command
        const gitTagValues = (0, shared_1.createGitTagValues)(releaseGroups, releaseGroupToFilteredProjects, versionResult.projectsVersionData);
        (0, shared_1.handleDuplicateGitTags)(gitTagValues);
        for (const tag of gitTagValues) {
            await (0, git_1.gitTag)({
                tag,
                message: nxReleaseConfig.git.tagMessage,
                additionalArgs: nxReleaseConfig.git.tagArgs,
                dryRun: args.dryRun,
                verbose: args.verbose,
            });
        }
    }
    let shouldPublish = !!args.yes && !args.skipPublish;
    const shouldPromptPublishing = !args.yes && !args.skipPublish && !args.dryRun;
    if (shouldPromptPublishing) {
        shouldPublish = await promptForPublish();
    }
    if (shouldPublish) {
        await (0, publish_1.releasePublish)(args);
    }
    else {
        console.log('Skipped publishing packages.');
    }
    return versionResult;
}
exports.release = release;
async function promptForPublish() {
    console.log('\n');
    try {
        const reply = await (0, enquirer_1.prompt)([
            {
                name: 'confirmation',
                message: 'Do you want to publish these versions?',
                type: 'confirm',
            },
        ]);
        return reply.confirmation;
    }
    catch (e) {
        console.log('\n');
        // Handle the case where the user exits the prompt with ctrl+c
        return false;
    }
}
