"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isComponent = exports.getBundlerFromTarget = exports.addCTTargetWithBuildTarget = void 0;
const devkit_1 = require("@nx/devkit");
const ensure_typescript_1 = require("@nx/js/src/utils/typescript/ensure-typescript");
const ast_utils_1 = require("./ast-utils");
let tsModule;
const allowedFileExt = new RegExp(/\.[jt]sx?/);
const isSpecFile = new RegExp(/(spec|test)\./);
async function addCTTargetWithBuildTarget(tree, options) {
    let found = { target: options.buildTarget, config: undefined };
    // Specifically undefined as a workaround for Remix to pass an empty string as the buildTarget
    if (options.buildTarget === undefined) {
        const { findBuildConfig } = await Promise.resolve().then(() => require('@nx/cypress/src/utils/find-target-options'));
        found = await findBuildConfig(tree, {
            project: options.project,
            buildTarget: options.buildTarget,
            validExecutorNames: options.validExecutorNames,
        });
        assertValidConfig(found?.config);
    }
    const projectConfig = (0, devkit_1.readProjectConfiguration)(tree, options.project);
    projectConfig.targets['component-test'].options = {
        ...projectConfig.targets['component-test'].options,
        devServerTarget: found.target,
        skipServe: true,
    };
    (0, devkit_1.updateProjectConfiguration)(tree, options.project, projectConfig);
    return found;
}
exports.addCTTargetWithBuildTarget = addCTTargetWithBuildTarget;
function assertValidConfig(config) {
    if (!config) {
        throw new Error('Unable to find a valid build configuration. Try passing in a target for an app. --build-target=<project>:<target>[:<configuration>]');
    }
}
async function getBundlerFromTarget(found, tree) {
    if (found.target && found.config?.executor) {
        return found.config.executor === '@nrwl/vite:build' ||
            found.config.executor === '@nx/vite:build'
            ? 'vite'
            : 'webpack';
    }
    const { target, project } = (0, devkit_1.parseTargetString)(found.target, await (0, devkit_1.createProjectGraphAsync)());
    const projectConfig = (0, devkit_1.readProjectConfiguration)(tree, project);
    const executor = projectConfig?.targets?.[target]?.executor;
    return executor === '@nrwl/vite:build' || executor === '@nx/vite:build'
        ? 'vite'
        : 'webpack';
}
exports.getBundlerFromTarget = getBundlerFromTarget;
function isComponent(tree, filePath) {
    if (!tsModule) {
        tsModule = (0, ensure_typescript_1.ensureTypescript)();
    }
    if (isSpecFile.test(filePath) || !allowedFileExt.test(filePath)) {
        return false;
    }
    const content = tree.read(filePath, 'utf-8');
    const sourceFile = tsModule.createSourceFile(filePath, content, tsModule.ScriptTarget.Latest, true);
    const cmpDeclaration = (0, ast_utils_1.getComponentNode)(sourceFile);
    return !!cmpDeclaration;
}
exports.isComponent = isComponent;
