"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const devkit_1 = require("@nx/devkit");
const ssr_dev_server_impl_1 = require("@nx/webpack/src/executors/ssr-dev-server/ssr-dev-server.impl");
const path_1 = require("path");
const chalk = require("chalk");
const async_iterable_1 = require("@nx/devkit/src/utils/async-iterable");
const child_process_1 = require("child_process");
const fs_1 = require("fs");
const internal_1 = require("@nx/js/src/internal");
function getBuildOptions(buildTarget, context) {
    const target = (0, devkit_1.parseTargetString)(buildTarget, context);
    const buildOptions = (0, devkit_1.readTargetOptions)(target, context);
    return {
        ...buildOptions,
    };
}
function getModuleFederationConfig(tsconfigPath, workspaceRoot, projectRoot) {
    const moduleFederationConfigPathJS = (0, path_1.join)(workspaceRoot, projectRoot, 'module-federation.config.js');
    const moduleFederationConfigPathTS = (0, path_1.join)(workspaceRoot, projectRoot, 'module-federation.config.ts');
    let moduleFederationConfigPath = moduleFederationConfigPathJS;
    const fullTSconfigPath = tsconfigPath.startsWith(workspaceRoot)
        ? tsconfigPath
        : (0, path_1.join)(workspaceRoot, tsconfigPath);
    // create a no-op so this can be called with issue
    let cleanupTranspiler = () => { };
    if ((0, fs_1.existsSync)(moduleFederationConfigPathTS)) {
        cleanupTranspiler = (0, internal_1.registerTsProject)(fullTSconfigPath);
        moduleFederationConfigPath = moduleFederationConfigPathTS;
    }
    try {
        const config = require(moduleFederationConfigPath);
        cleanupTranspiler();
        return config.default || config;
    }
    catch {
        throw new Error(`Could not load ${moduleFederationConfigPath}. Was this project generated with "@nx/react:host"?\nSee: https://nx.dev/concepts/more-concepts/faster-builds-with-module-federation`);
    }
}
async function* moduleFederationSsrDevServer(options, context) {
    let iter = (0, ssr_dev_server_impl_1.default)(options, context);
    const p = context.projectsConfigurations.projects[context.projectName];
    const buildOptions = getBuildOptions(options.browserTarget, context);
    const moduleFederationConfig = getModuleFederationConfig(buildOptions.tsConfig, context.root, p.root);
    const remotesToSkip = new Set(options.skipRemotes ?? []);
    const remotesNotInWorkspace = [];
    const knownRemotes = (moduleFederationConfig.remotes ?? []).filter((r) => {
        const validRemote = Array.isArray(r) ? r[0] : r;
        if (remotesToSkip.has(validRemote)) {
            return false;
        }
        else if (!context.projectGraph.nodes[validRemote]) {
            remotesNotInWorkspace.push(validRemote);
            return false;
        }
        else {
            return true;
        }
    });
    if (remotesNotInWorkspace.length > 0) {
        devkit_1.logger.warn(`Skipping serving ${remotesNotInWorkspace.join(', ')} as they could not be found in the workspace. Ensure they are served correctly.`);
    }
    const devServeApps = !options.devRemotes
        ? []
        : Array.isArray(options.devRemotes)
            ? options.devRemotes
            : [options.devRemotes];
    for (const app of knownRemotes) {
        const [appName] = Array.isArray(app) ? app : [app];
        const isDev = devServeApps.includes(appName);
        const remoteServeIter = isDev
            ? await (0, devkit_1.runExecutor)({
                project: appName,
                target: 'serve',
                configuration: context.configurationName,
            }, {
                watch: isDev,
            }, context)
            : (0, async_iterable_1.mapAsyncIterable)((0, async_iterable_1.createAsyncIterable)(async ({ next, done }) => {
                const remoteProject = context.projectsConfigurations.projects[appName];
                const remoteServerOutput = (0, path_1.join)(devkit_1.workspaceRoot, remoteProject.targets.server.options.outputPath, remoteProject.targets.server.options.outputFileName);
                const pm = (0, devkit_1.getPackageManagerCommand)();
                (0, child_process_1.execSync)(`${pm.exec} nx run ${appName}:server${context.configurationName ? `:${context.configurationName}` : ''}`, { stdio: 'inherit' });
                const child = (0, child_process_1.fork)(remoteServerOutput, {
                    env: {
                        PORT: remoteProject.targets['serve-browser'].options.port,
                    },
                });
                child.on('message', (msg) => {
                    if (msg === 'nx.server.ready') {
                        next(true);
                        done();
                    }
                });
            }), (x) => x);
        iter = (0, async_iterable_1.combineAsyncIterables)(iter, remoteServeIter);
    }
    let numAwaiting = knownRemotes.length + 1; // remotes + host
    return yield* (0, async_iterable_1.tapAsyncIterable)(iter, (x) => {
        numAwaiting--;
        if (numAwaiting === 0) {
            devkit_1.logger.info(`[ ${chalk.green('ready')} ] http://${options.host ?? 'localhost'}:${options.port ?? 4200}`);
        }
    });
}
exports.default = moduleFederationSsrDevServer;
