"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadEsmModule = exports.createNodes = exports.createDependencies = void 0;
const devkit_1 = require("@nx/devkit");
const path_1 = require("path");
const get_named_inputs_1 = require("@nx/devkit/src/utils/get-named-inputs");
const fs_1 = require("fs");
const cache_directory_1 = require("nx/src/utils/cache-directory");
const calculate_hash_for_create_nodes_1 = require("@nx/devkit/src/utils/calculate-hash-for-create-nodes");
const constants_1 = require("next/constants");
const js_1 = require("@nx/js");
const cachePath = (0, path_1.join)(cache_directory_1.projectGraphCacheDirectory, 'next.hash');
const targetsCache = (0, fs_1.existsSync)(cachePath) ? readTargetsCache() : {};
const calculatedTargets = {};
function readTargetsCache() {
    return (0, devkit_1.readJsonFile)(cachePath);
}
function writeTargetsToCache(targets) {
    (0, devkit_1.writeJsonFile)(cachePath, targets);
}
const createDependencies = () => {
    writeTargetsToCache(calculatedTargets);
    return [];
};
exports.createDependencies = createDependencies;
exports.createNodes = [
    '**/next.config.{js,cjs,mjs}',
    async (configFilePath, options, context) => {
        const projectRoot = (0, path_1.dirname)(configFilePath);
        // Do not create a project if package.json and project.json isn't there.
        const siblingFiles = (0, fs_1.readdirSync)((0, path_1.join)(context.workspaceRoot, projectRoot));
        if (!siblingFiles.includes('package.json') &&
            !siblingFiles.includes('project.json')) {
            return {};
        }
        options = normalizeOptions(options);
        const hash = (0, calculate_hash_for_create_nodes_1.calculateHashForCreateNodes)(projectRoot, options, context, [
            (0, js_1.getLockFileName)((0, devkit_1.detectPackageManager)(context.workspaceRoot)),
        ]);
        const targets = targetsCache[hash] ??
            (await buildNextTargets(configFilePath, projectRoot, options, context));
        calculatedTargets[hash] = targets;
        return {
            projects: {
                [projectRoot]: {
                    root: projectRoot,
                    targets,
                },
            },
        };
    },
];
async function buildNextTargets(nextConfigPath, projectRoot, options, context) {
    const nextConfig = await getNextConfig(nextConfigPath, context);
    const namedInputs = (0, get_named_inputs_1.getNamedInputs)(projectRoot, context);
    const targets = {};
    targets[options.buildTargetName] = await getBuildTargetConfig(namedInputs, projectRoot, nextConfig);
    targets[options.devTargetName] = getDevTargetConfig(projectRoot);
    targets[options.startTargetName] = getStartTargetConfig(options, projectRoot);
    return targets;
}
async function getBuildTargetConfig(namedInputs, projectRoot, nextConfig) {
    const nextOutputPath = await getOutputs(projectRoot, nextConfig);
    // Set output path here so that `withNx` can pick it up.
    const targetConfig = {
        command: `next build`,
        options: {
            cwd: projectRoot,
        },
        dependsOn: ['^build'],
        cache: true,
        inputs: getInputs(namedInputs),
        outputs: [nextOutputPath, `${nextOutputPath}/!(cache)`],
    };
    return targetConfig;
}
function getDevTargetConfig(projectRoot) {
    const targetConfig = {
        command: `next dev`,
        options: {
            cwd: projectRoot,
        },
    };
    return targetConfig;
}
function getStartTargetConfig(options, projectRoot) {
    const targetConfig = {
        command: `next start`,
        options: {
            cwd: projectRoot,
        },
        dependsOn: [options.buildTargetName],
    };
    return targetConfig;
}
async function getOutputs(projectRoot, nextConfig) {
    let dir = '.next';
    if (typeof nextConfig === 'function') {
        // Works for both async and sync functions.
        const configResult = await Promise.resolve(nextConfig(constants_1.PHASE_PRODUCTION_BUILD, { defaultConfig: {} }));
        if (configResult?.distDir) {
            dir = configResult?.distDir;
        }
    }
    else if (typeof nextConfig === 'object' && nextConfig?.distDir) {
        // If nextConfig is an object, directly use its 'distDir' property.
        dir = nextConfig.distDir;
    }
    if (projectRoot === '.') {
        return `{projectRoot}/${dir}`;
    }
    else {
        return `{workspaceRoot}/${projectRoot}/${dir}`;
    }
}
async function getNextConfig(configFilePath, context) {
    const resolvedPath = (0, path_1.join)(context.workspaceRoot, configFilePath);
    let module;
    if ((0, path_1.extname)(configFilePath) === '.mjs') {
        module = await loadEsmModule(resolvedPath);
    }
    else {
        module = load(resolvedPath);
    }
    return module.default ?? module;
}
function normalizeOptions(options) {
    options ??= {};
    options.buildTargetName ??= 'build';
    options.devTargetName ??= 'dev';
    options.startTargetName ??= 'start';
    return options;
}
function getInputs(namedInputs) {
    return [
        ...('production' in namedInputs
            ? ['default', '^production']
            : ['default', '^default']),
        {
            externalDependencies: ['next'],
        },
    ];
}
const packageInstallationDirectories = ['node_modules', '.yarn'];
/**
 * Load the module after ensuring that the require cache is cleared.
 */
function load(path) {
    // Clear cache if the path is in the cache
    if (require.cache[path]) {
        for (const key of Object.keys(require.cache)) {
            if (!packageInstallationDirectories.some((dir) => key.includes(dir))) {
                delete require.cache[key];
            }
        }
    }
    // Then require
    return require(path);
}
/**
 * Lazily compiled dynamic import loader function.
 */
let dynamicLoad;
function loadEsmModule(modulePath) {
    const modulePathWithCacheBust = `${modulePath}?version=${Date.now()}`;
    dynamicLoad ??= new Function('modulePath', `return import(modulePath);`);
    return dynamicLoad(modulePathWithCacheBust);
}
exports.loadEsmModule = loadEsmModule;
