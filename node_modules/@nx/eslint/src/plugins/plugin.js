"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createNodes = void 0;
const path_1 = require("path");
const fs_1 = require("fs");
const globs_1 = require("nx/src/utils/globs");
const config_file_1 = require("../utils/config-file");
exports.createNodes = [
    (0, globs_1.combineGlobPatterns)(['**/project.json', '**/package.json']),
    (configFilePath, options, context) => {
        const projectRoot = (0, path_1.dirname)(configFilePath);
        options = normalizeOptions(options);
        const eslintConfigs = getEslintConfigsForProject(projectRoot, context.workspaceRoot);
        if (!eslintConfigs.length) {
            return {};
        }
        return {
            projects: {
                [projectRoot]: {
                    targets: buildEslintTargets(eslintConfigs, projectRoot, options),
                },
            },
        };
    },
];
function getEslintConfigsForProject(projectRoot, workspaceRoot) {
    const detectedConfigs = new Set();
    const baseConfig = (0, config_file_1.findBaseEslintFile)(workspaceRoot);
    if (baseConfig) {
        detectedConfigs.add(baseConfig);
    }
    let siblingFiles = (0, fs_1.readdirSync)((0, path_1.join)(workspaceRoot, projectRoot));
    if (projectRoot === '.') {
        // If there's no src folder, it's not a standalone project
        if (!siblingFiles.includes('src')) {
            return [];
        }
        // If it's standalone but doesn't have eslint config, it's not a lintable
        const config = siblingFiles.find((f) => config_file_1.ESLINT_CONFIG_FILENAMES.includes(f));
        if (!config) {
            return [];
        }
        detectedConfigs.add(config);
        return Array.from(detectedConfigs);
    }
    while (projectRoot !== '.') {
        // if it has an eslint config it's lintable
        const config = siblingFiles.find((f) => config_file_1.ESLINT_CONFIG_FILENAMES.includes(f));
        if (config) {
            detectedConfigs.add(`${projectRoot}/${config}`);
            return Array.from(detectedConfigs);
        }
        projectRoot = (0, path_1.dirname)(projectRoot);
        siblingFiles = (0, fs_1.readdirSync)((0, path_1.join)(workspaceRoot, projectRoot));
    }
    // check whether the root has an eslint config
    const config = (0, fs_1.readdirSync)(workspaceRoot).find((f) => config_file_1.ESLINT_CONFIG_FILENAMES.includes(f));
    if (config) {
        detectedConfigs.add(config);
        return Array.from(detectedConfigs);
    }
    return [];
}
function buildEslintTargets(eslintConfigs, projectRoot, options) {
    const isRootProject = projectRoot === '.';
    const targets = {};
    const targetConfig = {
        command: `eslint ${isRootProject ? './src' : '.'}`,
        cache: true,
        options: {
            cwd: projectRoot,
        },
        inputs: [
            'default',
            ...eslintConfigs.map((config) => `{workspaceRoot}/${config}`),
            '{workspaceRoot}/tools/eslint-rules/**/*',
            { externalDependencies: ['eslint'] },
        ],
    };
    if (eslintConfigs.some((config) => (0, config_file_1.isFlatConfig)(config))) {
        targetConfig.options.env = {
            ESLINT_USE_FLAT_CONFIG: 'true',
        };
    }
    targets[options.targetName] = targetConfig;
    return targets;
}
function normalizeOptions(options) {
    options ??= {};
    options.targetName ??= 'lint';
    return options;
}
